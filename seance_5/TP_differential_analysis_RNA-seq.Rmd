---
title: "Détection de gènes différentiellement exprimés à partir de données RNA-seq"
author: "Jacques van Helden"
date: '`r Sys.Date()`'
output:
  html_document:
    self_contained: no
    fig_caption: yes
    highlight: zenburn
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
    code_folding: "hide"
  beamer_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_tex: no
    slide_level: 2
    theme: Montpellier
    toc: yes
  revealjs::revealjs_presentation:
    theme: night
    transition: none
    self_contained: true
    css: ../slides.css
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
  slidy_presentation:
    smart: no
    slide_level: 2
    self_contained: yes
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    highlight: tango
    incremental: no
    keep_md: yes
    smaller: yes
    theme: cerulean
    toc: yes
    widescreen: yes
  ioslides_presentation:
    slide_level: 2
    self_contained: no
    colortheme: dolphin
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    smaller: yes
    toc: yes
    widescreen: yes
font-import: http://fonts.googleapis.com/css?family=Risque
subtitle: "Diplôme Interuniversitaire en Bioinformatique intégrative (DU-Bii 2019)"
font-family: Garamond
transition: linear
editor_options: 
  chunk_output_type: console
---


## Introduction

Depuis l'avénement du du séquençage massivement parallèle (NGS, Next Generation Sequencing) en 2007, la détection de gènes différentiellement exprimés (DEG) à partir de données transcriptomiques RNA-seq constitue l'une de ses application les plus populaires. 

Le principe est de mesurer, dans différentes conditions, la concentration d'ARN correspondant à chaque gène, et de comparer ces concentrations entre les échantillons de deux (**comparaison à 2 groupes** ou **binaire**) ou plusieurs conditions (comparaison **multi-groupes**).

Dès les premières analyses, les chercheurs se sont rendus compte que les méthodes classiques d'analyse différentielles (tests de Student, ANOVA) ne se prêtaient pas du tout à l'analyse de telles données, car leur nature diffère fondamentalement des hypothèss de travail sous-jacentes, pour différentes raisons. 

1. Le niveau d'expression d'un gène est quantifié sur une échelle discrète (comptage du nombre de lectures alignées qui chevauchent le gène), alors que les tests paramétriques reposent sur une hypoothèse de normalité. 

2. Les ordres de grandeur des comptages varient fortement d'un gène à l'autre: certains gènes ont une poignée de comptages par échantillons, d'autres des centaines de milliers. Les gènes très très fortement représentés correspondent généralement à des gènes non-codants (par exemple ARN ribosomique) ou à des fonctions cellulaires particulières liées au métabolisme de l'ARN, et on comprend les raisons biologiques de leur sur-représentation. Ils n'en constituent pas moins ce qu'on appelle en statistique des "valeurs aberrantes" ("outliers"). 

3. Les distributions de comptages comptent généralement un très grand nombre de valeurs nulles ("zero-inflated distributions"). 

4. Ces particularités posent des problèmes particuliers pour la normalisation des librairies de comptages : 

    - la présence d'outliers affecte fortement la moyenne, et de façon très instable, ce qui biaise fortement l'estimation de la tendance centrale. 
    
    - la stratégie de repli sur des estimateurs robustes, comme la médiane est contestable du fait du très grand nombre de valeurs nulles (dans certains cas, plusn d'un quart voire la moitié des gènes ont une valeur nulle pour un échantillon). 
    
    
Des méthodes spécifiques ont donc été développées dès 2010 pour affronter ces difficultés particulières de la normalisation et de l'analyse différentielle des données de RNA-seq. 


## But de ce TP

Le but de ce TP est d'effectuer une première exploration de l'analyse différentielle des données d'expression, sur base d'un petit cas d'étude simple: l'analyse transcriptionnelle de mutants de sporulation chez la levure **Saccharomyces cerevisiae**. 

## Cas d'étude

... A ECRIRE: DESCRIPTION DU CAS D'ETUDE


## Sources des données

## Paramètres de l'analyse

Nous définissons dans une variable R (de type liste) les paramètres de l'analyse. Ceci nous permettra de reproduire ultérieurement exactement la même succession d'étapes soit en utilisant des données différentes, soit en modifiant les paramètres particuliers (design, seuils, ...). 



```{r knitr_options, echo=FALSE, include=FALSE, eval=TRUE}

## Define options for the R markdown output
options(width = 300)
# options(encoding = 'UTF-8')
knitr::opts_chunk$set(
  fig.width = 5, fig.height = 5, 
  fig.path = 'figures/TP_',
  fig.align = "center", 
  size = "tiny", 
  echo = TRUE, 
  eval = TRUE, 
  warning = FALSE, 
  message = FALSE, 
  results = TRUE, 
  comment = "")

## Max number of digits for non-scientific notation
options(scipen = 12) 
```


```{r load_libraries}
## Load libraries
message("Loading libraries")
library(knitr)
library(kableExtra)
library(FactoMineR)
library(clues)
library(RColorBrewer)
library(ComplexHeatmap)
library(vioplot)

# library(corrplot)
library(FactoMineR)
library(ClassDiscovery)
# library(formattable)

```


```{r custom_parameters}



parameters <- list(
  data.folder = "data/GSE89530", # dossier des données
  # data.folder = "/shared/projects/du_bii_2019/data/module3/seance5/GSE89530" # on the IFB-cluster-core
  counts = "GSE89530_counts.tsv.gz",
  sample.descr = "GSE89530_samples.tsv.gz",
  alpha = 0.05, # seuil de significativité
  epsilon = 0.1 # pseudo-comptage pour la transformation log2
)

kable(t(data.frame(parameters)), col.names = "Parameter Value")

```


## Téléchargement des données


```{r load_data}
## List files in the data folder
# list.files(parameters$data.folder)

## Load counts of reads per gene
counts <- read.delim(file.path(parameters$data.folder, parameters$counts), row.names = 1, header = TRUE)

## Load sample descriptions
samples <- read.delim(file.path(parameters$data.folder, parameters$sample.descr), row.names = 1, header = TRUE)


```

La table de comptages comporte `r prettyNum(nrow(counts))` lignes (correspondant aux gènes) et `r ncol(counts)` colonnes (correspondant aux échantillons). Nous pouvons afficher un petit morceau de cette table, ens électionnant au hasard quelques lignes et colonnes. 

```{r display_some_counts}
some.genes <- sample(1:nrow(counts), size = 10, replace = FALSE)
some.samples <- sample(1:ncol(counts), size = 4, replace = FALSE)

kable(counts[some.genes, some.samples], caption = "Random selection of some genes and some columns of the raw count table. ")
```


Le tableau `r parameters$sample.descr` fournit une description de chaque échantillon. 

```{r sample-kable}
# print(samples[some.samples, ])
kable(samples[some.samples, ], 
      caption = "**Table de comptage de lectures (short reads) par gène.** Sélection arbitraire de quelques gènes (lignes) et échantillons (colonnes)", 
      align = "c")
```


## Exploration des données

Avant toute autre chose, il convient de mener une exploration préliminaire des données, afin de se familiariser avec leur distribution. 


### Statistiques descriptives

La fonction R `summary()` calcule des statistiques de base pour chaque colonne d'une matrice ou data frame. Nous imprimons ici un sous-ensemble de ces échantillons. 

```{r counts_summary, echo=TRUE}
summary(counts[, some.samples])
```

Nous pouvons calculer quelques paramètres additionnels, qui nous éclaireront sur les données. 

```{r count_stats}
all.counts.vector <- unlist(counts) # Regroup all counts in a vevtor to compute statistics

count.stats <- data.frame(
  mean = mean(all.counts.vector),
  sd = sd(all.counts.vector),
  iqr = IQR(all.counts.vector),
  min = min(all.counts.vector),
  P05 = quantile(all.counts.vector, probs = 0.05),
  Q1 = quantile(all.counts.vector, probs = 0.25),
  median = quantile(all.counts.vector, probs = 0.5),
  Q3 = quantile(all.counts.vector, probs = 0.75),
  P95 = quantile(all.counts.vector, probs = 0.95),
  P99 = quantile(all.counts.vector, probs = 0.99),
  max = max(all.counts.vector)
  )
kable(t(count.stats), caption = "Statistics on raw count values (all samples together)", digits = 1, col.names = NULL)
rm(all.counts.vector) ## Free memory space

```


### Distribution des comptages


```{r count_distribution, out.width="80%", fig.width=7, fig.height=5}
## Compute some basic statistics

## Display histogram of the raw counts
hist(unlist(counts), breaks = 100, xlab = "Reads per gene", ylab = "Number of observations", main = "Distribution of raw counts")
```

Cet histogramme n'est pas très informatif, car toutes les valeurs sont concentrées dans la première tranche (à l'extrême gauche). Ceci résulte du fiat que les intervalles de classe ont été définis sur base de l'étendue totale, et qu'il existe apparemment une observation qui a une valeur énorme par rapport aux autres (valeur aberrante, "**outlier**"). De fait, la valeur la plus élevée (`r max(counts)`) dépasse de très loin la moyenne (`r count.stats$mean`)

Afin de visualiser toute l'étendue des observations tout en mettant plus de détail sur les valeurs faibles, nous pouvons effectuer une transformation logarithmique. Nous devons cependant prêter attention à certains détails. 

- Conventionnellement, on utlise la transformation log2 pour les données RNA-seq, car elle fournit un découpage plus fin des valeurs couvertes. 

- Les données RnA-seq contiennent généralement un bon nombre de valeurs nulles (gènes non détectés), qui posent un problème pour la conversion logarithmique ($log(0) = -\infty$). On contourne ce problème en ajoutant aux comptages un petit nombre arbitraire, qu'on dénomme **pseudo-comptage** et qu'on symbolise par la lettre grècque epsilon ($\epsilon$). 

Il est cournant d'ajouter la valeur $1$, mais nous préférons ajouter une valeur inférieure à 1, pour bien distinguer les comptages réels (qui peuvent de fait prendre une valeur 1) des pseudo-comptages. 

Pour cette analyse nous choisissons $\epsilon = `r  parameters$epsilon`$.

La conversion donne donc. 


$$\text{log2count}= log2(n + \epsilon) = log2(n + `r parameters$epsilon`) $$
L'histogramme des log2counts est plus informatif que celui des comptages bruts. 

```{r log2_conversion, out.width="80%", fig.width=7, fig.height=5}
counts.log2 <- log2(counts + parameters$epsilon)

hist(unlist(counts.log2), 
     xlab = "log2(counts + epsilon)", 
     ylab = "Number of observations", 
     main = "Distribution of log2(counts)", 
     breaks = 100, col = "#BBDDEE")
```

Notons d'emblée le pic très élevé à gauche, qui correspond à toutes les observations nulles. Sur l'axe $X$, il apparait à la valeur $`r signif(digits = 2, log2(parameters$epsilon))`$, qui correspond à $log_2(\epsilon) = log_2(`r parameters$epsilon`)$. 


## Boîtes à moustache

Les boîtes à moustache sont très utilisées pour obtenir une vision d'ensemble de plusieurs distribution. 

```{r boxplots, out.width="80%", fig.width=10, fig.height=7, fig.cap="**Boxplot of the counts per gene in each sample.** Left: raw counts. Right: log2_transformed counts. "}

## Associate a specific color to each condition
conditions <- unique(samples$Condition)
condition.colors <- rainbow(n = length(conditions))
names(condition.colors) <- conditions

## Associate a color to each sample according to its condition
samples$color <- condition.colors[samples$Condition]

# Box plot of counts and log2-transformed counts
par(mfrow = c(1,2))
mar.ori <- par("mar") # Store the original value of the margin parameter
par(mar = c(5.1, 10.1, 4.1, 1.1)) # Increase leftmargin for sample labels

boxplot(counts, horizontal = TRUE, las = 1, names = samples$Label, col = samples$color, xlab = "Raw counts")

boxplot(counts.log2, horizontal = TRUE, las = 1, names = samples$Label, col = samples$color, xlab = "log2counts")

par(mar = mar.ori) # reset original margins
par(mfrow = c(1,1))

```



```{r violin_plot, out.width="80%", fig.width=10, fig.height=8, fig.cap="**Violin plots**. Left: raw counts. Right: log2-transformed counts. "}
 
# Violin Plots
# 
# vioplot(x1, x2, x3, names=c("4 cyl", "6 cyl", "8 cyl"), 
#    col="gold")
# title("Violin Plots of Miles Per Gallon")
# 
# as.list(counts[1:10,1:2])
# library(sm)
# library(vioplot)
vioplot(as.list(counts), horizontal = TRUE, las = 1,
        col = samples$color)


```




